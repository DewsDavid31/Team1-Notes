These are some notes from research in git and messing around


Using git:


git add <file or directory wanted>
    In visual studio: >Git: Stage (when file is opened)
        for staging all changes:
            In visual studio >Git: Stage All changes
            In Bash: git add -a
    temporarily holds the files currently looked at by editor or near ls of terminal
    According to documentation, stores a directory into an "Index" abstractly

git commit -m "message"
    In Visual Studio: >Git: Commit
    prepares updates to file for repo upload and can notify the github site of this it appears
    According to documentation, stores index contents into what is called a Head

git push
    In visual studio: >Git: Push
    Appears to apply changes to repo on website if able, sometimes an argument of the repo used is required in command line
    Can sometimes need the remote url if connection not established it seems
    According to practice and documentation, pushes head information to remote server and clears the entire 'tree' of data from head to index after

git pull <url>
    In Visual Studio: >Git: Pull
        Visual studio appears to assume current file is pulled to
    Appears to merge from remote to current ls location

git fetch <url>
    In Visual Studio: >Git: fetch
        In VS temporarily opens current version of file
        In command line, appears to produce a copy of the current file pulled at ls location or specified path

Our Source Code, pre-adjustments:
Types file: contains all the objects required for project
    Item class:
        items are stubbed currently, containing no code inside
    Holder class:
        Inventory containers, currently only stubbed
    Player:
        Built-in Holder is given as argument
        Currently creates a Room field without arguments
        No other functionality

    Room:
        Room to be used on map
        Has a parent map field, list of entrances and exits
        Also has a list of players currently inhabiting
        !! As a practice, entrances should only be entereed by players,while exits only 
                only used to be exited by players
    Path:
        Abstractly built to be the connection between a Room's pointers, such as doors
            Contains an entrance and exit Room
    Map:
        Actualy map of rooms in the game, will contain all objects later on
            !! Currently only has a list of room objects

_Init_ File: Appears to only have version tag and author tag to add to program

_Main_: Appears to be the main launching file, running other programs and importing libraries

cli file: According to techtarget.com, is the Command Line Interface file that deals with extra arguments added by command line when starting the program

tests: The code appears to have assertion code for the existance of all object types currently existing
        as well as multiple instance of said objects in runtime.
        There are also tests that the CLI has a -h for help and the CLI exists in general
        
Notes on zork1:
what I like:
    Writing is impeccible
    Puzzling and fun
    Able to use many synonyms
    Consistantly follows two word syntax
what I dislike:
    Has no description of syntax of commands
    Go to says got there but does nothing

what could be changed:
    Syntax could be explained through item on person?
    Some more synonyms could be added such as ran to or go to
    Some elements of the game become zany like the troll eating you lantern, maybe more sensical puzzles could be made?

The scrum guide:

Scrum   Framework for developing, delivering and sustaining complex products
            made in early 1990's
Usages  Originally meant to manage developed products, but can be for:
            R+D of markets
            Developing products
            Frequent re-releases
            Cloud maintenance and Development
            Renewing products
Theory  Built on process control theory or Empiricism:
            Knowledge is from experience and decisions on known information.
                To control risk, Scrum incrementally controls development.
3 Pillars   Transparency, Inspection, Adaptation


Headfirst design patterns ch1: Intro to design patterns
    Usage and benefits of patterns found by wisdom of past coders

The duck problem    A method called fly() on a duck pond simulation program is inherited to all Duck subclasses
                        Sadly, causes most fake ducks to fly as well, as well as not making code easy to maintain and fix
                        Could be overriden but would require updating the Duck class for each subclass forever

Problem with inheritance    Code is duplicated but adjusting at runtime is difficult and unintended behavior can be added to subclasses

Interface Solution  a Flyable interface is made calling its own fly() methods could avoid duplication, but needs constant tweaking

Encapsulation Principle     "Identify aspects of you app that can vary and seperate them from what stays the same"
                                In most cases of maintenance, we want to be able to remove and replace changing patterns        
                                    Basis of all design patterns
Interface Principle         "Program to an interface, not an implementation"
                                Changing parts should be made into an interface or abstract interface for established
                                    This allows methods called by interface to be decided on runtime for flexibility
                                    ex: dog a= new dog(); becomes Animal a = new Dog(); or Animal a = getAnimal();
                                            a.makeSound();
    Pros:   Allows other classes to reuse set of behaviors, can be applied at any part of the dev cycle

How to integrate behavior   1) Add instance variables to main class that are interface in types
                            2) Each class polymorphically points to specified swappable behavior
                            3) Implement interface- main class calls offloaded method on runtime
                            4) Subclasses intitialize with given behaviors
                            5) Apply set behavior in setter and getter for on-runtime swapping/adjusting

Composition Principle   "Favor composition over inheritance"
                            Encapsulated features are generally more flexible than superclassing and allow runtime swapping

Strategy patterns   Family of algorithmns that encapsulate a set of behaviors for interchangability
                        Most useful for independent changes and preferences from users

Chapter 2 headfirst design patterns: Observer pattern




