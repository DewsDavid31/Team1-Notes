These are some notes from research in git and messing around


Using git:


git add <file or directory wanted>
    In visual studio: >Git: Stage (when file is opened)
        for staging all changes:
            In visual studio >Git: Stage All changes
            In Bash: git add -a
    temporarily holds the files currently looked at by editor or near ls of terminal
    According to documentation, stores a directory into an "Index" abstractly

git commit -m "message"
    In Visual Studio: >Git: Commit
    prepares updates to file for repo upload and can notify the github site of this it appears
    According to documentation, stores index contents into what is called a Head

git push
    In visual studio: >Git: Push
    Appears to apply changes to repo on website if able, sometimes an argument of the repo used is required in command line
    Can sometimes need the remote url if connection not established it seems
    According to practice and documentation, pushes head information to remote server and clears the entire 'tree' of data from head to index after

git pull <url>
    In Visual Studio: >Git: Pull
        Visual studio appears to assume current file is pulled to
    Appears to merge from remote to current ls location

git fetch <url>
    In Visual Studio: >Git: fetch
        In VS temporarily opens current version of file
        In command line, appears to produce a copy of the current file pulled at ls location or specified path

Our Source Code, pre-adjustments:
Types file: contains all the objects required for project
    Item class:
        items are stubbed currently, containing no code inside
    Holder class:
        Inventory containers, currently only stubbed
    Player:
        Built-in Holder is given as argument
        Currently creates a Room field without arguments
        No other functionality

    Room:
        Room to be used on map
        Has a parent map field, list of entrances and exits
        Also has a list of players currently inhabiting
        !! As a practice, entrances should only be entereed by players,while exits only 
                only used to be exited by players
    Path:
        Abstractly built to be the connection between a Room's pointers, such as doors
            Contains an entrance and exit Room
    Map:
        Actualy map of rooms in the game, will contain all objects later on
            !! Currently only has a list of room objects

_Init_ File: Appears to only have version tag and author tag to add to program

_Main_: Appears to be the main launching file, running other programs and importing libraries

cli file: According to techtarget.com, is the Command Line Interface file that deals with extra arguments added by command line when starting the program

tests: The code appears to have assertion code for the existance of all object types currently existing
        as well as multiple instance of said objects in runtime.
        There are also tests that the CLI has a -h for help and the CLI exists in general
        
Notes on zork1:
what I like:
    Writing is impeccible
    Puzzling and fun
    Able to use many synonyms
    Consistantly follows two word syntax
what I dislike:
    Has no description of syntax of commands
    Go to says got there but does nothing

what could be changed:
    Syntax could be explained through item on person?
    Some more synonyms could be added such as ran to or go to
    Some elements of the game become zany like the troll eating you lantern, maybe more sensical puzzles could be made?

The scrum guide:

Scrum   Framework for developing, delivering and sustaining complex products
            made in early 1990's
Usages  Originally meant to manage developed products, but can be for:
            R+D of markets
            Developing products
            Frequent re-releases
            Cloud maintenance and Development
            Renewing products
Theory  Built on process control theory or Empiricism:
            Knowledge is from experience and decisions on known information.
                To control risk, Scrum incrementally controls development.
3 Pillars   Transparency, Inspection, Adaptation


Headfirst design patterns ch1: Intro to design patterns
    Usage and benefits of patterns found by wisdom of past coders

The duck problem    A method called fly() on a duck pond simulation program is inherited to all Duck subclasses
                        Sadly, causes most fake ducks to fly as well, as well as not making code easy to maintain and fix
                        Could be overriden but would require updating the Duck class for each subclass forever

Problem with inheritance    Code is duplicated but adjusting at runtime is difficult and unintended behavior can be added to subclasses

Interface Solution  a Flyable interface is made calling its own fly() methods could avoid duplication, but needs constant tweaking

Encapsulation Principle     "Identify aspects of you app that can vary and seperate them from what stays the same"
                                In most cases of maintenance, we want to be able to remove and replace changing patterns        
                                    Basis of all design patterns
Interface Principle         "Program to an interface, not an implementation"
                                Changing parts should be made into an interface or abstract interface for established
                                    This allows methods called by interface to be decided on runtime for flexibility
                                    ex: dog a= new dog(); becomes Animal a = new Dog(); or Animal a = getAnimal();
                                            a.makeSound();
    Pros:   Allows other classes to reuse set of behaviors, can be applied at any part of the dev cycle

How to integrate behavior   1) Add instance variables to main class that are interface in types
                            2) Each class polymorphically points to specified swappable behavior
                            3) Implement interface- main class calls offloaded method on runtime
                            4) Subclasses intitialize with given behaviors
                            5) Apply set behavior in setter and getter for on-runtime swapping/adjusting

Composition Principle   "Favor composition over inheritance"
                            Encapsulated features are generally more flexible than superclassing and allow runtime swapping

Strategy patterns   Family of algorithmns that encapsulate a set of behaviors for interchangability
                        Most useful for independent changes and preferences from users

Chapter 2 headfirst design patterns: Observer pattern

Example     A weather station needing to update a bunch of display devices on current forecast

Problem     We want to maintain a link with an assortment of devices and display types without wasting code

Main pattern    We encapsulate a Publisher and Subscriber model, called Subject and Observer in our cases

Observers       Can subscribe or unsubscribe to updates by registering or deregistering with Subject

The pieces involved     Need a ConcreteSubject class pointing to a Subject interface that can call or be called by an Observer interface pointed by a concreteObserver object
                            This is done such that the data, and behaviors of each piece are easily changable like pattern 1
Pros        Cleaner sharing of same data
Cons        Can be counterintuititve in certain implementations

Loose Coupling  Interaction with little publicity to each other piece
                    Code reuse is indepenedent from Observer and Subject sides

Loose Coupling Principle    "Strive for loosely coupled designs between objects that interact!"
                                Allows objects to interact more flexibly

The general paradigm
                        Subject object deals with nitty gritty setters and getters, Subject then uses interface to call notify when changes occur in getters and setters
                        Said notify either calls observer interface's update method, injecting new data or has observer inteface call getters and setters on sent instance 
                        of Subject from Subject itself to later work with given information in actual concreteObserver as it wishes.

Subject interface   
                        registerObserver - takes observer as argument to add to arraylist usually
                        removeObserver - removes observer from arrayList to no longer be notified
                        notifyObserver - sends reference of itself and data object usually, null if nothing changed
Observer interface      
                        update - called using arguments specified by api to be states/data that currently changed in Subject

displayElement
                        The concreteObserver usually, could do anything since Subject doesn't know or creates

Push               When the Subject is set such that data is injected into observer class
Pull                When a Subject is set such that observers get data from passed instance of Subject

Java's supported    Has built-in libraries for Observable type and Observer classes 
                        Allows both push and pull as well as custom settings for when updates occur
How to change updates      notify will never be called unless setChanged() is called first, allowing programmers to specify when data should be pushed or pulled

Issues in Usage     Observable cannot be trusted to produce data in a specific order upon pull or push
                     Observer is a class not an interface in java supported libraries, not flexible in implememntation
                        setChanged() cannot be sub-classed

Head-first patterns Ch 3 Decorator pattern:
    Example         A coffee shop is struggling to update its massive menu with changing costs and build-your-own format of beverages

    Original setup  Superclass of Beverage, subclassing each possible combination and each beverage has a cost method   
                        An attrocity, could cause millions upon millions of classes and cost adjustments cannot be easily applied!

    Open-Closed Principle   "Classes should be open for extension, but closed to modification"
        Allows stability, but flexible usage of code
            Comes at the price of complexity!!

    Decorator big-picture   Base object is wrapped in added object wrapped in added object and so on. To call methods, call outside wrapper, which calls inside wrapper etc. etc.
        Lends itself to recursion in my mind
        Requires each wrapper to be the same type as its enwrapped object!!!
            Because it is the same type, the entire pile of wrappers can be passed around as one single object of its type!!

    implementation  Components, or base objects are made with interfaces
                        concreteComponent uses and interface of Component to then be wrapped in Decorator interface that is used by the concreteDecorator class
                            All parts must have the same recursive function, but concreteDecorator can have as many methods as it wishes!
    Drawbacks   Fails to function properly on component-only calculations such as end-of-sale discounts because then each layer would have to know previous layers
                Order cannot be guaranteed without other patterns!!
                Can produce an insane amount of small instances and may require extensive libraries with counterintutive combinations!!

    Java.IO     Uses this pattern extensively with components being InputStreams and wrappers being BufferedReader and other readers

5 Dysfunctions Part 1: The Fable
    A fictional company used to be the talk-of-the-town and contains allstar workers, but has been lackluster. The Company commander-in-chief, Jeff was asked to step down
    because of an abysmal performance recently, he is replaced by Kathyrn with much controversy.

    Kathyrn-    was a previos blue-collar exec, family gal, put on team because she was seen as a successful buisness woman in manufacturing deals without much expertise at all.
    Personal friends with chairman that appointed her. She is seen as a cultural outlier and met with controversy for commanding a culture she isn't a part of.

    The staff       What the employees call themselves, probably to avoid being called a team out of distrust and dislike

        Jeff        Former CEO, network guru but fails to properly manage. His meetings are bland and lifeless without a care about progress. He creates micromanaged agendas, minutes and documents of 
        meetings but fails to produce any results.

        Mikey       Marketing, a brand-building titan with a pedigree. Socially clueless and complains openly about disagreement with her choices. Often causes unneeded drama.

        Martin      Chief technoloist, a professional inventor that created original specifications with many accolades. Fails to care about participation and is often distracted. Snarky toward any ignorance and learning.

        JK          Another Jeff, but initilized for less confusion. Sales, more seasoned and older than most staff. Very honest and transparent but is non-commital and flakey. Used to be punctual.

        Carlos      Customer support, position is only for when company grows. Quiet listener, downplays successes, very bored but no issues.

        Jan         Chief Financial Officer, Devil in the details person, miserly as her position should be and prideful about her work. She is not much of a problem.

        Nick        Chief Operating Officer, Most accolades. Forced himself into position as bargaining chip. Wanted to shine, but duties ground to a halt when company plummeted. Not vocal but airs superiority on others.

Kathyrn proceeded to make the company uneasy by researching and observing how the staff interacted on the daily, as well as suggesting a sebatical for all workers to restart things.

Effective Java Ch 1: Introduction

Libraries we will use   util, io and the various contained libraries in util

Rules                   each chapter and section will have a rule that professional Developers follow

Pillars                 Clarity, Simplicity, User should never be surprised by an objects behavior, components should be as small as possible, never copy...reuse and dependencies should be minimized!

Our book                Some sections require IO boiler-plate imports on the books website to work
                        Will refer to inheritance as subclassing
                        Uses extends and implements interchangably instead of interfacing
                        Exported API will refer to classes, interfaces ,construction members and forms programmers access to define it

Reference types         types such as: Interfaces, Classes and arrayList

objects                 are class instances and arrays

class-members           are fields, methods, members classes and member intefaces inside the class body

signature               the name, types and formal parameters of a method

client-API              class that uses an API

Effective Java ch2: Creating and destroying objects

Item 1          "Consider static factory methods over constructors!"
                    A class can fetch an instance without invoking built-in constructors

Factory methods
		A method that returns the reference of an instance
			1) Is named unlike a constructor
			2) Has overload capabilities with the same arguments
			3) Order of args is easier
			4) Not required to create an instance each time
			5) Can control existance of objects to be singleton
			6) Can return an object of any type
			7) Can be private
			8) Return can now be vargs
			9) Can now return whole families of objects in a lightweight fashion
			10) Return type can only exist at runtime if it is wished
		ex: Enum classes work this way specifically
	
	Cons	1) Still needs to have a constructor to subclass
		2) Hard for programmers to naturally discover in an API

	Common names of commands
		from	type conversion of an arg
		of	fusing arguments into instance
		valueOf	same as of
		instance/getInstance	returns an instance of arg, but can change each next call
		create 			same as instance but guaranteed a new object each time
		getType		if factory method is called in other class
		newType		create but called in other class
		type		same as newType

Item 2	"Consider a builder when faced with many parameters in a constructor"
	Factory methods and constructors suck at being readable and fast with many params

Traditional approach	constructors for each argument size get called from largest calling smaller
				Called Telescopic constructor
					Better reading than normal for variable size construction
					but still horrible to read and adjust
Javabeans pattern	create and argumentless constructor that calls getters and setters of member				object to create using getters as arguments.
				Better to read, but unstable in states of each argument, hard
				to debug!!
				Impossible to be immutable!!
Builder pattern		Client calls a constructor or static factory with the parameters, while
			constructor gets member object called builder to use getters and setters on 			    arguments and then upon build method, builder makes instance of object with 			parameters.
				Simulates the optional arguments of soft-typed optional vars
				Requires checking valid values and states!!
				Must check fields after copying for security!!
				Amazing against class hierarchies! Can be nested for chaining!

Hierarchal builders		Nest builders in subclasses to be recursively called for construction of large, multipart objects
				Requires generic typing to work as well ass self method to subclass!!
				When implemented properly, allows multiple vargs!
				Can get around java's lack of self type called simulated self type idiom

Cons			Verbose unless 4+ args could happen, Builders make objects slowly with small amounts of arguments!

Item 3		"Enforce singleton property with private constructors or enum typing"
			A class can use only one instance with the use of private construction or enums

Singleton	A class with a member object or itself only instantiated once
		Near impossible to test due to no mocking!!

2 approaches	1) use final on instance member in private constructor
			Client can still break using reflection to call private construction!!
				To fix this, throw an exception if done twice+
			Preferred option unless generics or flexible input
		2) create a static factory with only one reference created
			Also can be reflected, same solution!!
			Simpler and more flexible also has generics capability

Making serializable	to make this serializable instance fields must be made transient!!
			provide a readResolve to prevent accidental duplicates on deserial!!

Enum approach	Most preferrable, serializable by default, immune to reflection!!
			Cannot extend superclassing other than enum type!!
				To fix this, interface it instead!!

Item 4		"Enforce non-instantiability with private constructors!"

static class	sometimes utility methds and values can be grouped when instantiating would be useless
		Abstract methods cannot prevent subclassing and instantiating
			To prevent this, create a private constructor to prevent ever calling hidden constructor
				Put in an assertionError to prevent itself accidentally constructing!!

Item 5	"Prefer dependency injection to hardwiring resources!"

Dependency injection	Some items need to be singleton members or used as a utility but need to be swapped out with other possible behaviors on runtime.
				To do this, we inject a dependency member in its constructor
					This allows immutability but ability to swap behavior
						Backbone of factory pattern

Downside	can clutter up large projects very quickly unless framework is used!!

Item 6		"Avoid creating unnecessary objects!"
			If an object becomes expensive to create or cumbersome to store, cache it!

Regex		Regex methods often are expensive to construct due to using state machines, to prevent this always use .compile() to field results for later usage without instantiating!

Autoboxing	When concatenating or typing both can end up creating seperate instances on each new item
			To fix this, store results, use builders or use sole primitives
			Can cause amazing slowdowns if not

Pooling		Do never pool objects for use manually unless deadling with heavy objects in databases!!

Item 7		"Eliminate obsolete object references"
			Always unpoint inactive or useless objects for garbage collection
Problem		all objects that are referenced by anything are never garbage collected in java
			To fix this, you can nullify, but be warned nullifying clutters code!!
				Only null if really done in future!!
Best practice	Use scope to nullify references by making references within a method only and cease to exist out of scope, nullifying!!
			Only nullify if unavoidable in scope!!
caches		Can easily be forgotten as references
			if only active when referenced:
				use weakHashMap, it derefrences inactive keys
			if not known when inactive:
				periodically dereference items by method side effect or background thread
					See java.lang.ref if need more help

listeners and callbacks		always use a weakHashmap!

Heap Profiler		a debug tool that can detect small memory leaks, use sparingly

Item 8		"Avoid finalizers and cleaners"
			They suck in every way, and should feel bad

		1) They are dependent on garbage collection, which is slow
		2) Never guaranteed to be done
		3) Slow down processing by a buttload
		4) They ignore any and all catching and throwing (especially finalize)
			This allows a finalizer attack
Finalizer attack	Finalize can be invoked and then never throw an exception or lock, allowing illegal operations to occur, such as creating a malicious and impossible object to do its bidding
			To prevent this use AutoClosable and try-with-resources

Only 2 uses
		1) safety net in case nothing else can be done to clear the heap
		2) non-native code needs to be un-instantiated

Cleaners	Less dangerous, but still attrociously slow, pollute readability, hard to use!
			Registers an object to clear and clears using argument resources

Item 9 		"Prefer try-with-resources to try-finally"
			try-finally originally for closing when exceptions are caught, but allows exceptions to behave incorrectly when happening during finally{}
			Multiple arguments require multiple finally{}!!
				Looks awful
			Can also throw itself while running ignoring error!!
try-with-resources	Requires AutoClosable to run, but doesn't need multiple finally for multiple arguments and suppresses errors customly.
				Catch works inside it too!!
Parse Tree:  A tree of all inputs divided out into parsed tokens
Abstract Syntax Tree: A refined parse tree, removes some superluous information in forming tree
    Follows a specific syntax   


Spike: Command Data Structures:
    List objects: Ordered collection of items
        Syntax [<literal>,<literal>,<literal>...]
        Can add, remove or search similar to Java's arrayList
    Tuple: Used to hold multiple objects
        Hold Strings of contained objects in csv form
        Used when statement or user-defined function will not change       
            Similar to array in java
        Syntax: ('','','',''...)
        Acccess:    new_tuple[item][item inside]...
        Tuples are stored in multi-dimensional array form for nesting
    Dictionary: Address-book analog, Keys paired to a value like a Java map
        Keys are immutable, values are not
        No order
        .del can delete a key-value paired
        .items() reuturns all Tuples
    Sequence: Superclass of List and Tuple and str

    Set: unordered collection of primitives
        Used for set theory and Binary Algebra mostly
            Hence permutation is useless
    !! copying collections passes by reference!!

Spike: Command Handling

    Interpreter vs Compiler:    Interpreter converts input into another language or format, Compiler converts input into raw commands or data

    Parsing:        Analysis of a text into syntactical components
        Ways of parsing text:
            1) Complex parsing:     Sending raw text through a primitive class(such as dictionary or split list) then into a complex framework(Panda's Dataframe, etc.)
                    Useful if there is not format, allowing the created framework to discover/sort the data with tweaking
            2) String manipulation: If the text is in consistant format, standard Split() lists and dictionaries can slice up data and manipulate and categorize it
                Seperate text manually with pre-defined splitting methods and agreed-upon format of input
            3) Regex:               Regular expressions can use its own language to functionally seperate text if the format is somewhat consistant, but complex
                    Use regex filter to match keys to paired text slices
                    Usually said to be the worst route
        How Parsing works:
            Structure:  
                Lexer: Parser contains this, Often a Scanner or Tokenizer. 
                        Scans a given raw text and produces matching tokens based on rules or productions decided upon.
                Proper Parser: Converts given tokens from lexer into abstract tree of a statement.
                    Ex: 437 + 12 -> lexer: NUM OPERATOR NUM -> parser: Sum_of(NUM,NUM)

                These rules are often specified in markup languages for that purpose

                Abstract Tree: A produced tree of the result of proper-parser, often pruned to create a Concrete Syntax Tree for better standards and easier usage
                    This is usually done by the developer's decisions or the user's
                    !! Beware, information is lost going from Abstract to Concrete in Grammar!!
                    
6/12 In-class notes
    Smith   Will give us an API for the game in YAML form

    dictionaries    Python loves maps, I mean *cough* Dictionaries, most efficient in Python

    Approaches:     2d dictionary: Verbs:values -> objects: values

    Method-references:      Strength of Python Functional passing, methods are considered objects themselves
                                Ex: def foo(){} -> actually is a value, we can def bar(foo()){}
                                    Methods can be a value in a dictionary!!
                                        !! use instead of if/then/else!!
    Aliases:                Cannot use lists as keys
                                Method should deal with Aliases
    
    Non-functional requirements:    Performance, Real-time Performance, Maintainable, Modifiable, Readable, etc.
                                        Come on a scale unlike functional requirements

    Analysis
        Two kinds:
                
                1) static - stats on code before running -> sonarcloud/pylint/radon
                    linters, cyclomatic complexity(number of paths/ reading complexity), method length
                2) dynamic - stats on code while running -> spotbugs/valgrind/purify
                    We are not using dynamic during class
    
    Testing:
        1) Acceptance - Client requirements met
        2) Unit: method - TDD, test per method write before any code is written. Fail first then succeed
        3) Integration: class - Testing classes meshing together
        4) System - Testing entire system

    Unit Test: most important
        write test, make sure it fails, write enough to make it work
        If you can't write a test, don't write the code

            Implementation: requirements, design and process
                Bad implementation is a project crasher
                    Follow style of pep8!!
                        Pylint will notify, other tools will check
                            Naming: kramer's rules on Naming
                                !!avoid hungarian notation: using type in name!!
                            Tests: must be easy to run,50:50 code and test
                                Run quickly and a lot
                            Libraries: Use often, but cited
                                Use another library wherever possible
                            Reviews: very effective for improving capability
                                Knowing others look affects quality
                                Others know things you don't
                                
    Agile: Emphasizes quick release cycles, allow changes in design on the fly
            
                            Also communication standards, book of style will help communicate
    Leadership vs. mgmt: mgmt finding strengths and weaknesses of team members and their ways to success, leadership find commonalities for unity of team and direction
        Mgmt is carrot, leadership is stick
            !!Both are needed in a team!!
