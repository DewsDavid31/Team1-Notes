Effective Java Ch 1: Introduction

Libraries we will use   util, io and the various contained libraries in util

Rules                   each chapter and section will have a rule that professional Developers follow

Pillars                 Clarity, Simplicity, User should never be surprised by an objects behavior, components should be as small as possible, never copy...reuse and dependencies should be minimized!

Our book                Some sections require IO boiler-plate imports on the books website to work
                        Will refer to inheritance as subclassing
                        Uses extends and implements interchangeably instead of interfacing
                        Exported API will refer to classes, interfaces ,construction members and forms programmers access to define it

Reference types         types such as: Interfaces, Classes and arrayList

objects                 are class instances and arrays

class-members           are fields, methods, members classes and member intefaces inside the class body

signature               the name, types and formal parameters of a method

client-API              class that uses an API

Effective Java ch2: Creating and destroying objects

Item 1          "Consider static factory methods over constructors!"
                    A class can fetch an instance without invoking built-in constructors

Factory methods
		A method that returns the reference of an instance
			1) Is named unlike a constructor
			2) Has overload capabilities with the same arguments
			3) Order of args is easier
			4) Not required to create an instance each time
			5) Can control existance of objects to be singleton
			6) Can return an object of any type
			7) Can be private
			8) Return can now be vargs
			9) Can now return whole families of objects in a lightweight fashion
			10) Return type can only exist at runtime if it is wished
		ex: Enum classes work this way specifically
	
	Cons	1) Still needs to have a constructor to subclass
		2) Hard for programmers to naturally discover in an API

	Common names of commands
		from	type conversion of an arg
		of	fusing arguments into instance
		valueOf	same as of
		instance/getInstance	returns an instance of arg, but can change each next call
		create 			same as instance but guaranteed a new object each time
		getType		if factory method is called in other class
		newType		create but called in other class
		type		same as newType

Item 2	"Consider a builder when faced with many parameters in a constructor"
	Factory methods and constructors suck at being readable and fast with many params

Traditional approach	constructors for each argument size get called from largest calling smaller
				Called Telescopic constructor
					Better reading than normal for variable size construction
					but still horrible to read and adjust
Javabeans pattern	create and argumentless constructor that calls getters and setters of member				object to create using getters as arguments.
				Better to read, but unstable in states of each argument, hard
				to debug!!
				Impossible to be immutable!!
Builder pattern		Client calls a constructor or static factory with the parameters, while
			constructor gets member object called builder to use getters and setters on 			    arguments and then upon build method, builder makes instance of object with 			parameters.
				Simulates the optional arguments of soft-typed optional vars
				Requires checking valid values and states!!
				Must check fields after copying for security!!
				Amazing against class hierarchies! Can be nested for chaining!

Hierarchal builders		Nest builders in subclasses to be recursively called for construction of large, multipart objects
				Requires generic typing to work as well ass self method to subclass!!
				When implemented properly, allows multiple vargs!
				Can get around java's lack of self type called simulated self type idiom

Cons			Verbose unless 4+ args could happen, Builders make objects slowly with small amounts of arguments!

Item 3		"Enforce singleton property with private constructors or enum typing"
			A class can use only one instance with the use of private construction or enums

Singleton	A class with a member object or itself only instantiated once
		Near impossible to test due to no mocking!!

2 approaches	1) use final on instance member in private constructor
			Client can still break using reflection to call private construction!!
				To fix this, throw an exception if done twice+
			Preferred option unless generics or flexible input
		2) create a static factory with only one reference created
			Also can be reflected, same solution!!
			Simpler and more flexible also has generics capability

Making serializable	to make this serializable instance fields must be made transient!!
			provide a readResolve to prevent accidental duplicates on deserial!!

Enum approach	Most preferrable, serializable by default, immune to reflection!!
			Cannot extend superclassing other than enum type!!
				To fix this, interface it instead!!

Item 4		"Enforce non-instantiability with private constructors!"

static class	sometimes utility methds and values can be grouped when instantiating would be useless
		Abstract methods cannot prevent subclassing and instantiating
			To prevent this, create a private constructor to prevent ever calling hidden constructor
				Put in an assertionError to prevent itself accidentally constructing!!

Item 5	"Prefer dependency injection to hardwiring resources!"

Dependency injection	Some items need to be singleton members or used as a utility but need to be swapped out with other possible behaviors on runtime.
				To do this, we inject a dependency member in its constructor
					This allows immutability but ability to swap behavior
						Backbone of factory pattern

Downside	can clutter up large projects very quickly unless framework is used!!

Item 6		"Avoid creating unnecessary objects!"
			If an object becomes expensive to create or cumbersome to store, cache it!

Regex		Regex methods often are expensive to construct due to using state machines, to prevent this always use .compile() to field results for later usage without instantiating!

Autoboxing	When concatenating or typing both can end up creating seperate instances on each new item
			To fix this, store results, use builders or use sole primitives
			Can cause amazing slowdowns if not

Pooling		Do never pool objects for use manually unless dealing with heavy objects in databases!!

Item 7		"Eliminate obsolete object references"
			Always unpoint inactive or useless objects for garbage collection
Problem		all objects that are referenced by anything are never garbage collected in java
			To fix this, you can nullify, but be warned nullifying clutters code!!
				Only null if really done in future!!
Best practice	Use scope to nullify references by making references within a method only and cease to exist out of scope, nullifying!!
			Only nullify if unavoidable in scope!!
caches		Can easily be forgotten as references
			if only active when referenced:
				use weakHashMap, it dereferences inactive keys
			if not known when inactive:
				periodically dereference items by method side effect or background thread
					See java.lang.ref if need more help

listeners and callbacks		always use a weakHashmap!

Heap Profiler		a debug tool that can detect small memory leaks, use sparingly

Item 8		"Avoid finalizers and cleaners"
			They suck in every way, and should feel bad

		1) They are dependent on garbage collection, which is slow
		2) Never guaranteed to be done
		3) Slow down processing by a buttload
		4) They ignore any and all catching and throwing (especially finalize)
			This allows a finalizer attack
Finalizer attack	Finalize can be invoked and then never throw an exception or lock, allowing illegal operations to occur, such as creating a malicious and impossible object to do its bidding
			To prevent this use AutoClosable and try-with-resources

Only 2 uses
		1) safety net in case nothing else can be done to clear the heap
		2) non-native code needs to be un-instantiated

Cleaners	Less dangerous, but still atrociously slow, pollute readability, hard to use!
			Registers an object to clear and clears using argument resources

Item 9 		"Prefer try-with-resources to try-finally"
			try-finally originally for closing when exceptions are caught, but allows exceptions to behave incorrectly when happening during finally{}
			Multiple arguments require multiple finally{}!!
				Looks awful
			Can also throw itself while running ignoring error!!
try-with-resources	Requires AutoClosable to run, but doesn't need multiple finally for multiple arguments and suppresses errors customly.Catch works inside it too!!

Chapter 4: classes and interfaces
	item 15 - minimize the accessbility of classes and members
		API and implementation should be decoupled, the less known the better
			Encapsulation - allow swapping and testing
				allows paralell development
			protected, private and public are java's mechanisms for this
			top-level classes = package private and public
			
			private - member is accesible from declared top-class
			package-private - member is accessible from any class in same package
				!!This is default except for interfaces == public!!
			protected- only accessable through subclasses of class it was declared
			public- accessable from everywhere!

			Tests can be made as part of package to gain package-private

			!!instance fields of public should not be made private if possible!!

			 decide on public api, make rest private, flip default if needed, but shouldn't often, if done often change encapsulation
			!! if Serializable is used can leak members into api!!
			
		Static fields follow similar rules except exposure of constants to public is fine.
			!!Must be immutable or primitive due to inheritance!!
			!!arrays are mutable always!!
			
				One alternative is a public copy of a private
				another is a public list to call that copies private
		java 9: added module safety
			module- grouping of packages
				Protected by export declarations: public and protected, act like the originals
				Rarely used, often can be made by rearranging the classes in packages
				!! advisory, non-functional if a jar is added to class path!!
					But unexported are enforced by the jvm
	Item 16: in public classes, use accessor methods, not public fields

		Degenerate classes - classes that only instantiate variables should not be public
			These cannot benefit from encapsulation
			Best practice OO believes they should be replaced by private fields with getters and setters
				!! unless private, in which case less clutter is direct!!

			Java often does this with awt
		!!if you can't avoid it make it immutable!!

	Item 17: minimize mutability 
		Classes should be immutable unless there is reason not to
			Why immutable?
				Thread-safe, atomic, no need to copy(!!Don't clone!!), secure, shareable!
			Why not?
				Take up more space for each copy, could be costly, can't work in mutable usage
			Why mutable?
				performance of changes can be easier by a lot
			
		If you are stuck with mutable:
			Make a companion immutable class if needed only
			limit its mutability as much as possible
						
