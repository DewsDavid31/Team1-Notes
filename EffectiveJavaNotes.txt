Effective Java Ch 1: Introduction

Libraries we will use   util, io and the various contained libraries in util

Rules                   each chapter and section will have a rule that professional Developers follow

Pillars                 Clarity, Simplicity, User should never be surprised by an objects behavior, components should be as small as possible, never copy...reuse and dependencies should be minimized!

Our book                Some sections require IO boiler-plate imports on the books website to work
                        Will refer to inheritance as subclassing
                        Uses extends and implements interchangeably instead of interfacing
                        Exported API will refer to classes, interfaces ,construction members and forms programmers access to define it

Reference types         types such as: Interfaces, Classes and arrayList

objects                 are class instances and arrays

class-members           are fields, methods, members classes and member intefaces inside the class body

signature               the name, types and formal parameters of a method

client-API              class that uses an API

Effective Java ch2: Creating and destroying objects

Item 1          "Consider static factory methods over constructors!"
                    A class can fetch an instance without invoking built-in constructors

Factory methods
		A method that returns the reference of an instance
			1) Is named unlike a constructor
			2) Has overload capabilities with the same arguments
			3) Order of args is easier
			4) Not required to create an instance each time
			5) Can control existance of objects to be singleton
			6) Can return an object of any type
			7) Can be private
			8) Return can now be vargs
			9) Can now return whole families of objects in a lightweight fashion
			10) Return type can only exist at runtime if it is wished
		ex: Enum classes work this way specifically
	
	Cons	1) Still needs to have a constructor to subclass
		2) Hard for programmers to naturally discover in an API

	Common names of commands
		from	type conversion of an arg
		of	fusing arguments into instance
		valueOf	same as of
		instance/getInstance	returns an instance of arg, but can change each next call
		create 			same as instance but guaranteed a new object each time
		getType		if factory method is called in other class
		newType		create but called in other class
		type		same as newType

Item 2	"Consider a builder when faced with many parameters in a constructor"
	Factory methods and constructors suck at being readable and fast with many params

Traditional approach	constructors for each argument size get called from largest calling smaller
				Called Telescopic constructor
					Better reading than normal for variable size construction
					but still horrible to read and adjust
Javabeans pattern	create and argumentless constructor that calls getters and setters of member				object to create using getters as arguments.
				Better to read, but unstable in states of each argument, hard
				to debug!!
				Impossible to be immutable!!
Builder pattern		Client calls a constructor or static factory with the parameters, while
			constructor gets member object called builder to use getters and setters on 			    arguments and then upon build method, builder makes instance of object with 			parameters.
				Simulates the optional arguments of soft-typed optional vars
				Requires checking valid values and states!!
				Must check fields after copying for security!!
				Amazing against class hierarchies! Can be nested for chaining!

Hierarchal builders		Nest builders in subclasses to be recursively called for construction of large, multipart objects
				Requires generic typing to work as well ass self method to subclass!!
				When implemented properly, allows multiple vargs!
				Can get around java's lack of self type called simulated self type idiom

Cons			Verbose unless 4+ args could happen, Builders make objects slowly with small amounts of arguments!

Item 3		"Enforce singleton property with private constructors or enum typing"
			A class can use only one instance with the use of private construction or enums

Singleton	A class with a member object or itself only instantiated once
		Near impossible to test due to no mocking!!

2 approaches	1) use final on instance member in private constructor
			Client can still break using reflection to call private construction!!
				To fix this, throw an exception if done twice+
			Preferred option unless generics or flexible input
		2) create a static factory with only one reference created
			Also can be reflected, same solution!!
			Simpler and more flexible also has generics capability

Making serializable	to make this serializable instance fields must be made transient!!
			provide a readResolve to prevent accidental duplicates on deserial!!

Enum approach	Most preferrable, serializable by default, immune to reflection!!
			Cannot extend superclassing other than enum type!!
				To fix this, interface it instead!!

Item 4		"Enforce non-instantiability with private constructors!"

static class	sometimes utility methds and values can be grouped when instantiating would be useless
		Abstract methods cannot prevent subclassing and instantiating
			To prevent this, create a private constructor to prevent ever calling hidden constructor
				Put in an assertionError to prevent itself accidentally constructing!!

Item 5	"Prefer dependency injection to hardwiring resources!"

Dependency injection	Some items need to be singleton members or used as a utility but need to be swapped out with other possible behaviors on runtime.
				To do this, we inject a dependency member in its constructor
					This allows immutability but ability to swap behavior
						Backbone of factory pattern

Downside	can clutter up large projects very quickly unless framework is used!!

Item 6		"Avoid creating unnecessary objects!"
			If an object becomes expensive to create or cumbersome to store, cache it!

Regex		Regex methods often are expensive to construct due to using state machines, to prevent this always use .compile() to field results for later usage without instantiating!

Autoboxing	When concatenating or typing both can end up creating seperate instances on each new item
			To fix this, store results, use builders or use sole primitives
			Can cause amazing slowdowns if not

Pooling		Do never pool objects for use manually unless dealing with heavy objects in databases!!

Item 7		"Eliminate obsolete object references"
			Always unpoint inactive or useless objects for garbage collection
Problem		all objects that are referenced by anything are never garbage collected in java
			To fix this, you can nullify, but be warned nullifying clutters code!!
				Only null if really done in future!!
Best practice	Use scope to nullify references by making references within a method only and cease to exist out of scope, nullifying!!
			Only nullify if unavoidable in scope!!
caches		Can easily be forgotten as references
			if only active when referenced:
				use weakHashMap, it dereferences inactive keys
			if not known when inactive:
				periodically dereference items by method side effect or background thread
					See java.lang.ref if need more help

listeners and callbacks		always use a weakHashmap!

Heap Profiler		a debug tool that can detect small memory leaks, use sparingly

Item 8		"Avoid finalizers and cleaners"
			They suck in every way, and should feel bad

		1) They are dependent on garbage collection, which is slow
		2) Never guaranteed to be done
		3) Slow down processing by a buttload
		4) They ignore any and all catching and throwing (especially finalize)
			This allows a finalizer attack
Finalizer attack	Finalize can be invoked and then never throw an exception or lock, allowing illegal operations to occur, such as creating a malicious and impossible object to do its bidding
			To prevent this use AutoClosable and try-with-resources

Only 2 uses
		1) safety net in case nothing else can be done to clear the heap
		2) non-native code needs to be un-instantiated

Cleaners	Less dangerous, but still atrociously slow, pollute readability, hard to use!
			Registers an object to clear and clears using argument resources

Item 9 		"Prefer try-with-resources to try-finally"
			try-finally originally for closing when exceptions are caught, but allows exceptions to behave incorrectly when happening during finally{}
			Multiple arguments require multiple finally{}!!
				Looks awful
			Can also throw itself while running ignoring error!!
try-with-resources	Requires AutoClosable to run, but doesn't need multiple finally for multiple arguments and suppresses errors customly.Catch works inside it too!!

Chapter 4: classes and interfaces
	item 15 - minimize the accessbility of classes and members
		API and implementation should be decoupled, the less known the better
			Encapsulation - allow swapping and testing
				allows paralell development
			protected, private and public are java's mechanisms for this
			top-level classes = package private and public
			
			private - member is accesible from declared top-class
			package-private - member is accessible from any class in same package
				!!This is default except for interfaces == public!!
			protected- only accessable through subclasses of class it was declared
			public- accessable from everywhere!

			Tests can be made as part of package to gain package-private

			!!instance fields of public should not be made private if possible!!

			 decide on public api, make rest private, flip default if needed, but shouldn't often, if done often change encapsulation
			!! if Serializable is used can leak members into api!!
			
		Static fields follow similar rules except exposure of constants to public is fine.
			!!Must be immutable or primitive due to inheritance!!
			!!arrays are mutable always!!
			
				One alternative is a public copy of a private
				another is a public list to call that copies private
		java 9: added module safety
			module- grouping of packages
				Protected by export declarations: public and protected, act like the originals
				Rarely used, often can be made by rearranging the classes in packages
				!! advisory, non-functional if a jar is added to class path!!
					But unexported are enforced by the jvm
	Item 16: in public classes, use accessor methods, not public fields

		Degenerate classes - classes that only instantiate variables should not be public
			These cannot benefit from encapsulation
			Best practice OO believes they should be replaced by private fields with getters and setters
				!! unless private, in which case less clutter is direct!!

			Java often does this with awt
		!!if you can't avoid it make it immutable!!

	Item 17: minimize mutability 
		Classes should be immutable unless there is reason not to
			Why immutable?
				Thread-safe, atomic, no need to copy(!!Don't clone!!), secure, shareable!
			Why not?
				Take up more space for each copy, could be costly, can't work in mutable usage
			Why mutable?
				performance of changes can be easier by a lot
			
		If you are stuck with mutable:
			Make a companion immutable class if needed only
			limit its mutability as much as possible
	Item 18:

	Item 53: Use varargs judiciously
		Variable arity method- method that accepts varargs
			Creates an array the size of the arguments, packs the args in said array then passing into said method
				Used for 0+ argument overloading
				!!DO NOT CHECK FOR 0 ARGS and throw!!
					fails runtime, ugly
					Solution, have arg 0 be a regular argument
			Syntax: method(type... args){
	
	Item 54: Return empty collections or arrays, not nulls
		Never return a special case null, this requires another piece to interpret and handle a null situation(ex: if empty => null)
			If this is too costly to return empty collection, return the same reference each time!!
 	Item 55: Return optionals judiciously
		A third option of returning when otherwise impossible: Optional<T> can contain a single value also including nothing
			Basically a forced version of returning an empty collection
			!!doesn't use collection<T> but could in principle!!
			ex: extends optional<E>
				return Optional.empty() or Optional.of(value) as factories of Optionals
			!!But don't use it as a panacea!!
			!!Don't use on boxed types,undefined behavior except with:!!
				Boolean, Byte, Character, Short, Float
			!!Never us as a key or element in a collection!!
	Item 56: Write doc comments for all exposed API elements
		If an API is usable from outside, it must must must be documented
		Were done by hand, which became arduous
		Javadoc made it automated, not officially part of java but widely used
		
		To doc properly:
			1) Make a doc comment before each exported class, interface, constructor, method and field declaration
			2) Doc comment for methods get a succinct contract between method and client
				States what it does, not how!!
				Preconditions - things that must be true to invoke method
				postconditions - things that will be true after invoking method
				side-effect - change made in state of system not required to achieve post-conditions
				MUST INCLUDE:
				1st sentence is a summary description !!beware, auto-ends at first period with whitespace!!
				use 3rd person declaritive, returns a ball
				
				@return <has punctuation>
				@param 
				@throws
				 all as full sentences including @word
					@code prevents html parsing, and shows in code font
					Allows examples
				@implSpec showing self-use patterns if using inheritance
					contract between method and it's subclass
					needs -tag "implSpec:a:ImplementationRequirements:"
					to use as of java 9
				@literal operates like code, minus the font to allow <>!&
				@inheritDoc can inherit documentation, otherwise if unknown, the javadoc has a search algorithmn for the most applicable doc
				
			3) Ensure they work in source code and generated documentation
			3.5) Document serialized form, if it has one
			4) Change any duplicate summaries that are the same
			5) If generics or generic, document all type parameters
			6) Add all constants if Enum
			7) If annotation type, document all the members
			8) Always document thread safety of statics
			9) Doublecheck web pages made b javadoc
			
Chapter 9: General Programming 	

	item 57: Minimize the scope of local variables
		Increases reliability and accessibility of classes to members

	item 58: prefer for-each loops to tranditional for loops
		For-each loops get rid of clutter
		Handle collections without dealing with details
		Better at nested iteration- handles outer loop calls to not double-count like you naturally want to with a regular for loop
		when you can't use for-each:
			1)Destructive filtering: popping fails to work
			2)Transforming: Mutating elements doesn't work, need list iterator and index instead
			3)Paralell iteration: ensuring collections are at the same spot in a call, not entirely reliable to customly do in for each
				!!Use for loop instead, but beware nesting issues!!
			!!For each requires an object to be a collection<T> or an interable object, to do so you must write implementing iterable!
	item 59: Know and use libraries
		Items like random number generators are hard to test, and verify			It is best to just use a well known, expert library
			!!ThreadLocalRandom is better than MAth.Random!!
				Better random + faster after java 7
			Also saves time, and coverage
		When to not use a library?:
			Only when the library is not specialized enough
			!! familiarize yourself with libraries!!
	item 60: Avoid float and double when exact answers are required
		We learned this in Arm assembly, float and double of non power 2 numbers are guesses, and inaccruate
		
	item 61: Prefer primitive types to boxed primitives
		Java has primitve values and referenced values: Integer, Long...
		
		Differences:
			Prims: only have values, less costly
			Boxed: reference a value, can be null
				!!Beware auto-unboxing in <= operations, can change false -> true!!
			!! == is an identity comparison, not a value!!
			!!NEVER USE ON BOXED!!
			!!Beware unboxing a null ref Box!!
			!! Dont mix prim and box!!
			
	item 62: Avoid strings where other types are better
		String is godawful at any other type, if possible and not actually text, convert it stat!!
						
		!! Don't use for aggregates and enums!!

	item 63: Beware the performance of String cat
		+ is made convenient for immutable concatenation
		but is in O(n^2), which is fricking awful
		!!Use StringBuilder instead!!
		Use + for cognitive load if a few strings!
	
	item 64: Refer to Objects by their interfaces
	
		Always instantiate as interface, not concrete when decoupled
		
	item 65: Prefer interfaces to reflection
		Reflection allows access to arbitrary classes:
			You can gain constructor, method and field instances on runtime
			done by using built-in .invoke()
			!! bad for the reasons:!!
				1) can't check compile time exceptions
					Odd race cases by reaching in
				2) code looks nasty
				3) invoke is unreliable in speed
			Good if very limited: if you can't reach any other way
				can act as a testing harness of runtime items
				
	item 66: Use native methods judiciously
		native methods are written in other languages such as c or c++
			!! Don't use them for performance!!
			past Java 3 JVM was no longer necessary to use for speed
			Since then most libraries evolved beyond native!!
			less platform friendly and memory issue related
	item 67: optimize judiciously
		1) most issues come from obsession with efficiency
		2)small efficiencies are not effective
		3)don't do it until you need it

		Strive for quality over speed!!
		Strive for flexbility over limiting for speed
		consider the performance concerns of api however
			But dont warp api for it!!
		Be sure to measure gains from optimizing
		 			
